# Crocodile 任务调度系统.v3


# TODO
- [x] 用户管理  
      普通用户、管理员
- [x] 主机组管理
- [x] 主机管理
- [x] rpc调度任务执行
- [x] 调度任务采用tls加密、token认证
- [x] 任务操作[增加、删除、更新、查询、暂停调度]
- [x] 保存执行日志
- [x] 实现两种task Run 接口
- [x] 手动触发任务、终止任务、获取任务日志
- [x] 使用golint检测代码
- [ ] 获取正在运行的任务(websocket)
- [x] 删除主机，暂停主机运行任务
- [x] 运行任务流式返回数据
- [ ] 实时在线日志后端接口 
    - 任务执行结果需要流式的返回 
    - 运行任务重写
- [ ] grpc keepalive
- [ ] worker下线通知中心节点
- [ ] 定时删除执行日志
- [ ] grpc validator
- [ ] 多种调度算法
    - 随机
    - 最少任务数
    - 权重
    - 轮询执行
- [ ] 报警
    - 通过检测返回结果、状态码，来判断是否报警，默认只检查返回码。
    - 报警方式: email，telegram, slack,server 酱(有报警限制)，钉钉，webhooks，
- [ ] 前端
- [ ] Prometheus+grafana 监控
- [ ] 任务标签, 任务模版
- [ ] 压力测试
- [ ] 操作审计
- [ ] 直接运行go文件，python，shell
- [ ] 调度中心集群
    - DB锁
        缺点
            - 所有集群必须连接到同一个DB，这就无法使用sqlite数据库了
        优点
            - 选择速度很快
            - 实现简单
    - 类似Raft的选主过程
        缺点
            - 选举时间可能会有一些耗时
            - 实现获取有些复杂
        优点
            - 不需要连接同一个数据库
            
    -首先所有调度中心集群的节点时间必须一致，使用ntp来同步，
    集群中所有调度需要先给其他节点发送调度请求包，通过投票机制来选择唯一一个需要调度的节点然后通过这个节点来发送调度请求，类似raft协议,必须确保每次调度都需要选出一个发送调度的服务器。
    每个服务器会维持一个关于任务运行次数的序号，集群中所有机器的序号必须统一，如果不统一那就少数服从多数的序号，集群中的节点运行时，需要先将自已保存的任务序号发送到其他节点，如果其他的节点当前的序号小于接收到的序号，那么其他的节点就返回发起投票的机制，最终会选出一个。
    调度流程
    选举调度节点不应该超过100ms
    - 当调度器中的任务可以运行时，向集群中所有节点发送一个任务可以运行，然后将这个任务的序号+1后发送给集群中的所有节点，然后集群中的其他节点首先要判断这个任务的序号与自已本地的任务序号，如果存在一个节点的序号大于这个值，那么发送请求调度的节点就会忽略这次调度，并将任务的序号修改为接收到的的任务序号，并忽略本次调度。
    - 如果这次调度被集群中的所有节点允许了，那么就开始投票选择可以运行的节点，如果计算可以参与选举的节点呢，当一个集群节点中的任务需要运行时，会在本地维持一个计时器，会等待500ms


